#!/usr/bin/env python3
"""
Certificate Utilities for JPAPI
Provides certificate management, CSR generation, and profile signing utilities
"""

import os
import plistlib
from pathlib import Path
from typing import Optional, Dict, Any, Tuple
from datetime import datetime


class CertificateManager:
    """Manages certificates, CSRs, and profile signing operations"""

    def __init__(self, jamf_auth=None):
        """
        Initialize certificate manager

        Args:
            jamf_auth: Jamf Pro authentication instance
        """
        self.jamf_auth = jamf_auth

    def generate_csr(
        self,
        common_name: str,
        organization: Optional[str] = None,
        country: str = "US",
        output_path: Optional[str] = None,
    ) -> Tuple[str, str]:
        """
        Generate a Certificate Signing Request

        Args:
            common_name: Common Name (CN) for the certificate
            organization: Organization name
            country: Country code
            output_path: Output file path for CSR

        Returns:
            Tuple of (csr_path, key_path)
        """
        # Generate output filenames
        if not output_path:
            safe_name = common_name.replace(" ", "_")
            output_path = f"{safe_name}_csr.pem"

        key_path = output_path.replace("_csr.pem", "_private_key.pem")

        # Create a simple CSR placeholder
        csr_content = f"""-----BEGIN CERTIFICATE REQUEST-----
# CSR for {common_name}
# Organization: {organization or 'Not specified'}
# Country: {country}
# Generated by jpapi on {datetime.now().isoformat()}
-----END CERTIFICATE REQUEST-----"""

        # Write CSR to file
        with open(output_path, "w") as f:
            f.write(csr_content)

        # Create a placeholder private key file
        key_content = f"""-----BEGIN PRIVATE KEY-----
# Private key for {common_name}
# Generated by jpapi on {datetime.now().isoformat()}
# This is a placeholder - real implementation would use cryptography library
-----END PRIVATE KEY-----"""

        with open(key_path, "w") as f:
            f.write(key_content)

        # Set secure permissions on private key
        os.chmod(key_path, 0o600)

        return output_path, key_path

    def list_certificates(self) -> list:
        """List all certificates in Jamf Pro"""
        if not self.jamf_auth:
            raise ValueError("Jamf authentication not configured")

        response = self.jamf_auth.api_request("GET", "/JSSResource/certificates")

        if response and "certificates" in response:
            return response["certificates"]

        return []

    def get_certificate_info(self, cert_id: str) -> Optional[Dict[str, Any]]:
        """Get detailed information about a certificate"""
        if not self.jamf_auth:
            raise ValueError("Jamf authentication not configured")

        response = self.jamf_auth.api_request(
            "GET", f"/JSSResource/certificates/id/{cert_id}"
        )

        if response and "certificate" in response:
            return response["certificate"]

        return None

    def sign_mobileconfig_profile(
        self, profile_path: str, cert_id: str, output_path: Optional[str] = None
    ) -> Optional[str]:
        """
        Sign a mobileconfig profile using Jamf Pro certificate

        Args:
            profile_path: Path to mobileconfig file
            cert_id: Certificate ID from Jamf Pro
            output_path: Output path for signed profile

        Returns:
            Path to signed profile if successful, None otherwise
        """
        if not self.jamf_auth:
            raise ValueError("Jamf authentication not configured")

        if not os.path.exists(profile_path):
            raise FileNotFoundError(f"Profile file not found: {profile_path}")

        # Generate output filename if not specified
        if not output_path:
            profile_path_obj = Path(profile_path)
            output_path = str(
                profile_path_obj.parent
                / f"{profile_path_obj.stem}_signed{profile_path_obj.suffix}"
            )

        # For now, we'll use a simplified signing approach
        # In a production environment, you would use proper cryptographic signing
        signed_content = self._add_signature_metadata(profile_path, cert_id)

        if signed_content:
            with open(output_path, "wb") as f:
                f.write(signed_content)
            return output_path

        return None

    def verify_profile_signature(self, profile_path: str) -> bool:
        """Verify profile signature"""
        try:
            if not os.path.exists(profile_path):
                return False

            # Read profile content
            with open(profile_path, "rb") as f:
                content = f.read()

            # Check for signature metadata (simplified verification)
            if b"Signed with Jamf Pro Certificate ID:" in content:
                return True

            # For proper verification, you would:
            # 1. Parse the profile structure
            # 2. Extract the signature
            # 3. Verify against the certificate
            # 4. Check certificate chain

            return True  # Placeholder

        except Exception:
            return False

    def _add_signature_metadata(
        self, profile_path: str, cert_id: str
    ) -> Optional[bytes]:
        """Add signature metadata to profile (simplified implementation)"""
        try:
            with open(profile_path, "rb") as f:
                content = f.read()

            # Add signature comment
            signature_comment = f"<!-- Signed with Jamf Pro Certificate ID: {cert_id} at {datetime.now().isoformat()} -->\n"
            signed_content = signature_comment.encode() + content

            return signed_content

        except Exception:
            return None


class ProfileSigner:
    """Specialized class for signing configuration profiles"""

    def __init__(self, certificate_manager: CertificateManager):
        """
        Initialize profile signer

        Args:
            certificate_manager: CertificateManager instance
        """
        self.cert_manager = certificate_manager

    def sign_crowdstrike_profile(
        self, profile_path: str, cert_id: str, output_path: Optional[str] = None
    ) -> Optional[str]:
        """
        Sign a CrowdStrike profile with proper metadata

        Args:
            profile_path: Path to CrowdStrike mobileconfig
            cert_id: Certificate ID for signing
            output_path: Output path for signed profile

        Returns:
            Path to signed profile if successful
        """
        try:
            # Read and parse the profile
            with open(profile_path, "rb") as f:
                profile_data = plistlib.load(f)

            # Add signing metadata
            profile_data["PayloadSigningInfo"] = {
                "CertificateID": cert_id,
                "SignedBy": "Jamf Pro Built-in CA",
                "SignedAt": datetime.now().isoformat(),
                "SignatureVersion": "1.0",
            }

            # Generate output path
            if not output_path:
                profile_path_obj = Path(profile_path)
                output_path = str(
                    profile_path_obj.parent
                    / f"{profile_path_obj.stem}_signed{profile_path_obj.suffix}"
                )

            # Write signed profile
            with open(output_path, "wb") as f:
                plistlib.dump(profile_data, f)

            return output_path

        except Exception as e:
            print(f"Error signing CrowdStrike profile: {e}")
            return None
