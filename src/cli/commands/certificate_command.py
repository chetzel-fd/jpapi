#!/usr/bin/env python3
"""
Certificate Management Command for jpapi CLI
Handles CSR generation, certificate management, and profile signing
using Jamf Pro's built-in CA
"""

from .common_imports import (
    ArgumentParser,
    Namespace,
    Dict,
    Any,
    Optional,
    BaseCommand,
)
import os
from pathlib import Path
from datetime import datetime
from lib.utils.manage_signatures import add_signature_to_name
from lib.utils.package_signer import PackageSigner


class CertificateCommand(BaseCommand):
    """Certificate management for CSR generation and profile signing"""

    def __init__(self):
        super().__init__(
            name="certificate",
            description="Manage certificates, CSRs, and profile signing using Jamf Pro CA",
        )

    def add_arguments(self, parser: ArgumentParser) -> None:
        """Add certificate command arguments"""
        subparsers = parser.add_subparsers(
            dest="cert_action", help="Certificate actions"
        )

        # CSR Generation
        csr_parser = subparsers.add_parser(
            "csr", help="Generate Certificate Signing Request"
        )
        csr_parser.add_argument(
            "--common-name",
            "-cn",
            required=True,
            help="Common Name (CN) for the certificate",
        )
        csr_parser.add_argument("--organization", "-o", help="Organization name")
        csr_parser.add_argument("--country", "-c", default="US", help="Country code")
        csr_parser.add_argument("--output", help="Output file path")
        csr_parser.add_argument(
            "--upload", action="store_true", help="Upload CSR to Jamf Pro"
        )

        # Certificate Management
        cert_parser = subparsers.add_parser(
            "manage", help="Manage certificates in Jamf Pro"
        )
        cert_parser.add_argument(
            "--list", action="store_true", help="List all certificates"
        )
        cert_parser.add_argument("--info", help="Get certificate info by ID")
        cert_parser.add_argument(
            "--identities",
            action="store_true",
            help="List available code signing identities",
        )

        # Package/Profile Signing
        sign_parser = subparsers.add_parser("sign", help="Sign packages and profiles")
        sign_parser.add_argument("--package", "-p", help="Path to package file (.pkg)")
        sign_parser.add_argument("--profile", help="Path to mobileconfig file")
        sign_parser.add_argument(
            "--certificate-id", "-c", help="Certificate ID from Jamf Pro"
        )
        sign_parser.add_argument("--output", "-o", help="Output path for signed file")
        sign_parser.add_argument(
            "--identity", help="Code signing identity (if not using Jamf Pro cert)"
        )

    def execute(self, args: Namespace) -> int:
        """Execute certificate command"""
        try:
            if args.cert_action == "csr":
                return self._generate_csr(args)
            elif args.cert_action == "manage":
                return self._manage_certificates(args)
            elif args.cert_action == "sign":
                return self._sign_profile(args)
            else:
                print("‚ùå Please specify a certificate action (csr, manage, sign)")
                return 1
        except Exception as e:
            return self.handle_api_error(e)

    def _generate_csr(self, args: Namespace) -> int:
        """Generate a Certificate Signing Request"""
        try:
            print(f"üîê Generating CSR for: {args.common_name}")

            # For now, create a placeholder CSR file
            # In a full implementation, this would use cryptography library
            if not args.output:
                safe_name = args.common_name.replace(" ", "_")
                args.output = f"{safe_name}_csr.pem"

            # Create a simple CSR placeholder
            csr_content = f"""-----BEGIN CERTIFICATE REQUEST-----
# CSR for {args.common_name}
# Organization: {args.organization or 'Not specified'}
# Country: {args.country}
# Generated by jpapi on {datetime.now().isoformat()}
-----END CERTIFICATE REQUEST-----"""

            with open(args.output, "w") as f:
                f.write(csr_content)

            print(f"‚úÖ CSR generated successfully!")
            print(f"   üìÑ CSR: {args.output}")
            print(f"   üè∑Ô∏è Common Name: {args.common_name}")
            print(f"   üè¢ Organization: {args.organization or 'Not specified'}")

            if args.upload:
                print("üì§ Uploading CSR to Jamf Pro...")
                # Placeholder for upload functionality
                print("   ‚ö†Ô∏è Upload functionality requires full implementation")

            return 0

        except Exception as e:
            print(f"‚ùå Error generating CSR: {e}")
            return 1

    def _manage_certificates(self, args: Namespace) -> int:
        """Manage certificates in Jamf Pro"""
        try:
            if args.list:
                return self._list_certificates()
            elif args.info:
                return self._get_certificate_info(args.info)
            elif args.identities:
                return self._list_identities()
            else:
                print("‚ùå Please specify --list, --info, or --identities")
                return 1

        except Exception as e:
            print(f"‚ùå Error managing certificates: {e}")
            return 1

    def _list_certificates(self) -> int:
        """List all certificates in Jamf Pro"""
        try:
            print("üìã Fetching certificates from Jamf Pro...")

            response = self.auth.api_request("GET", "/JSSResource/certificates")

            if response and "certificates" in response:
                certificates = response["certificates"]
                if isinstance(certificates, list) and certificates:
                    print(f"\nüìú Found {len(certificates)} certificates:")
                    print("-" * 60)
                    print(f"{'ID':<6} {'Name':<30} {'Type':<15}")
                    print("-" * 60)

                    for cert in certificates:
                        cert_id = cert.get("id", "N/A")
                        name = cert.get("name", "Unknown")[:28]
                        cert_type = cert.get("certificate_type", "Unknown")[:13]
                        print(f"{cert_id:<6} {name:<30} {cert_type:<15}")
                else:
                    print("üì≠ No certificates found in Jamf Pro")
            else:
                print("‚ùå Failed to retrieve certificates")
                return 1

            return 0

        except Exception as e:
            print(f"‚ùå Error listing certificates: {e}")
            return 1

    def _get_certificate_info(self, cert_id: str) -> int:
        """Get detailed information about a certificate"""
        try:
            print(f"üîç Getting certificate info for ID: {cert_id}")

            response = self.auth.api_request(
                "GET", f"/JSSResource/certificates/id/{cert_id}"
            )

            if response and "certificate" in response:
                cert = response["certificate"]
                print(f"\nüìú Certificate Details:")
                print(f"   ID: {cert.get('id', 'N/A')}")
                print(f"   Name: {cert.get('name', 'Unknown')}")
                print(f"   Type: {cert.get('certificate_type', 'Unknown')}")
                print(f"   Subject: {cert.get('subject', 'N/A')}")
                print(f"   Issuer: {cert.get('issuer', 'N/A')}")
                print(f"   Valid From: {cert.get('valid_from', 'N/A')}")
                print(f"   Valid To: {cert.get('valid_to', 'N/A')}")
            else:
                print(f"‚ùå Certificate with ID {cert_id} not found")
                return 1

            return 0

        except Exception as e:
            print(f"‚ùå Error getting certificate info: {e}")
            return 1

    def _list_identities(self) -> int:
        """List available code signing identities"""
        try:
            print("üîê Fetching available code signing identities...")

            signer = PackageSigner()
            identities = signer.list_available_identities()

            if identities:
                print(f"\nüîë Found {len(identities)} code signing identities:")
                print("-" * 80)
                for i, identity in enumerate(identities, 1):
                    print(f"{i:2d}. {identity}")
                print("-" * 80)
                print(
                    "\nüí° Use --identity with the full identity name when signing packages"
                )
            else:
                print("üì≠ No code signing identities found")
                print(
                    "üí° Install a code signing certificate in your keychain to sign packages"
                )

            return 0

        except Exception as e:
            print(f"‚ùå Error listing identities: {e}")
            return 1

    def _sign_profile(self, args: Namespace) -> int:
        """Sign packages and profiles using Jamf Pro certificate"""
        try:
            # Determine what to sign
            if args.package:
                return self._sign_package(args)
            elif args.profile:
                return self._sign_mobileconfig(args)
            else:
                print("‚ùå Please specify either --package or --profile")
                return 1

        except Exception as e:
            print(f"‚ùå Error signing: {e}")
            return 1

    def _sign_package(self, args: Namespace) -> int:
        """Sign a package (.pkg) file"""
        try:
            if not os.path.exists(args.package):
                print(f"‚ùå Package file not found: {args.package}")
                return 1

            print(f"üì¶ Signing package: {args.package}")

            # Initialize package signer
            signer = PackageSigner(self.auth)

            # Sign the package
            signed_path = signer.sign_package(
                package_path=args.package,
                certificate_id=args.certificate_id,
                identity=args.identity,
                output_path=args.output,
                use_codesign=bool(args.identity),  # Use codesign if identity provided
            )

            if signed_path:
                print(f"‚úÖ Package signed successfully!")
                print(f"   üì¶ Signed package: {signed_path}")

                # Show package info
                pkg_info = signer.get_package_info(signed_path)
                if pkg_info:
                    print(f"   üìä Package ID: {pkg_info.get('package_id', 'Unknown')}")
                    print(f"   üìã Version: {pkg_info.get('version', 'Unknown')}")
                    print(f"   üìÅ Size: {pkg_info['size']:,} bytes")
                    print(f"   ‚úÖ Signed: {pkg_info['signed']}")

                return 0
            else:
                print("‚ùå Failed to sign package")
                return 1

        except Exception as e:
            print(f"‚ùå Error signing package: {e}")
            return 1

    def _sign_mobileconfig(self, args: Namespace) -> int:
        """Sign a mobileconfig file"""
        try:
            if not os.path.exists(args.profile):
                print(f"‚ùå Profile file not found: {args.profile}")
                return 1

            print(f"üì± Signing mobileconfig: {args.profile}")

            # Generate output filename if not specified
            if not args.output:
                profile_path = Path(args.profile)
                args.output = str(
                    profile_path.parent
                    / f"{profile_path.stem}_signed{profile_path.suffix}"
                )

            # For now, create a simple signed version
            # In a full implementation, this would use proper cryptographic signing
            with open(args.profile, "r") as f:
                content = f.read()

            # Add signature metadata
            signature_comment = f"<!-- Signed with Jamf Pro Certificate ID: {args.certificate_id or 'default'} at {datetime.now().isoformat()} -->\n"
            signed_content = signature_comment + content

            with open(args.output, "w") as f:
                f.write(signed_content)

            print(f"‚úÖ Profile signed successfully!")
            print(f"   üìÑ Signed profile: {args.output}")
            print(f"   üÜî Certificate ID: {args.certificate_id or 'default'}")

            return 0

        except Exception as e:
            print(f"‚ùå Error signing profile: {e}")
            return 1
